generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                    String                 @id
  firstName             String
  lastName              String?
  email                 String                 @unique
  username              String?                @unique
  phoneNumber           String?
  designation           String?
  bio                   String?
  socialWebsite         String?
  socialGithub          String?
  socialFacebook        String?
  socialTwitter         String?
  socialLinkedin        String?
  emailVerified         Boolean
  image                 String?
  createdAt             DateTime
  updatedAt             DateTime
  stripeCustomerId      String?                @unique
  role                  String?
  banned                Boolean?
  banReason             String?
  banExpires            DateTime?
  points                Int                    @default(0)
  assignmentSubmissions AssignmentSubmission[]
  quizSubmissions       QuizSubmission[]
  billingAddress        BillingAddress?
  courses               Course[]
  earlyUnlocks          EarlyUnlock[]
  enrollment            Enrollment[]
  lessonProgress        LessonProgress[]
  accounts              Account[]
  sessions              Session[]
  supportCallsCreated   SupportCall[]          @relation("SupportCallCreator")
  supportCallRequests   SupportCallRequest[]   @relation("SupportCallRequestUser")
  blogs                 Blog[]
  blogComments          BlogComment[]
  blogReactions         BlogReaction[]
  notifications         Notification[]
  memberships           Membership[]
  invitations           Invitation[]            @relation("InvitedUser")
  announcementsCreated  Announcement[]          @relation("AnnouncementCreator")
  announcementsRead     AnnouncementReadStatus[] @relation("AnnouncementReader")
  teacherApplications   TeacherApplication[]
  activityLogs          ActivityLog[]
  courseRatings         CourseRating[]
  courseRatingReactions CourseRatingReaction[]
  searchAnalytics       SearchAnalytics[]
  loginHistory          LoginHistory[]
  errorLogs             ErrorLog[]
  watchAnalytics        LessonWatchAnalytics[]
  onlineSessions        OnlineSession[]
  helpRequests          HelpRequest[]
  wishlist              Wishlist[]

  @@map("user")
}

model BillingAddress {
  id           String   @id @default(uuid())
  firstName    String
  lastName     String
  companyName  String?
  phoneNumber  String?
  email        String
  addressLine1 String
  addressLine2 String?
  city         String
  state        String
  postalCode   String
  country      String
  vatNumber    String?
  notes        String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  userId       String   @unique
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Session {
  id             String   @id
  expiresAt      DateTime
  token          String   @unique
  createdAt      DateTime
  updatedAt      DateTime
  ipAddress      String?
  userAgent      String?
  userId         String
  impersonatedBy String?
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String    @unique
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}

model Course {
  id               String        @id @default(uuid())
  title            String
  description      String
  fileKey          String
  price            Int
  duration         Int
  level            CourseLevel   @default(Beginner)
  stripePriceId    String        @unique
  category         String
  smallDescription String
  slug             String        @unique
  status           CourseStatus  @default(Draft)
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  userId           String
  chapter          Chapter[]
  user             User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  enrollment       Enrollment[]
  supportCalls     SupportCall[]
  blogs             Blog[]
  announcements     Announcement[]
  ratings           CourseRating[]
  wishlist          Wishlist[]
}

model Chapter {
  id           String        @id @default(uuid())
  title        String
  position     Int
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  courseId     String
  releaseAt    DateTime?
  status       ChapterStatus @default(Draft)
  Course       Course        @relation(fields: [courseId], references: [id], onDelete: Cascade)
  earlyUnlocks EarlyUnlock[]
  lessons      Lesson[]
}

model Lesson {
  id             String           @id @default(uuid())
  title          String
  description    String?
  thumbnailKey   String?
  videoKey       String?
  position       Int
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  chapterId      String
  assignment     Assignment?
  quiz           Quiz?
  Chapter        Chapter          @relation(fields: [chapterId], references: [id], onDelete: Cascade)
  lessonProgress LessonProgress[]
  earlyUnlocks   EarlyUnlock[]
  watchAnalytics LessonWatchAnalytics[]
  // Publish / visibility status
  status         LessonStatus     @default(Draft)
  // Optional scheduled publish time (used when status = Scheduled)
  releaseAt      DateTime?
}

model Enrollment {
  id                   String            @id @default(uuid())
  amount               Int
  status               EnrollmentStatus  @default(Pending)
  createdAt            DateTime          @default(now())
  updatedAt            DateTime          @updatedAt
  courseId             String
  userId               String
  banReason            String?
  banType              BanType?
  banUntil             DateTime?
  banned               Boolean?
  followUpEmailSent    Boolean           @default(false)
  lastActivityAt       DateTime?
  certificateEarned    Boolean           @default(false)
  certificateIssuedAt  DateTime?
  certificateKey       String?           @unique
  certificateRevoked   Boolean           @default(false)
  certificateRevokedAt DateTime?
  tags                 StudentTag[]
  Course               Course            @relation(fields: [courseId], references: [id], onDelete: Cascade)
  User                 User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  loginSessions        LoginSession[]
  studentActivities    StudentActivity[]
  studentBadges        StudentBadge[]
  paymentTransactions  PaymentTransaction[]

  @@unique([userId, courseId])
}

model StudentActivity {
  id           String       @id @default(uuid())
  type         ActivityType
  description  String?
  metadata     Json?
  createdAt    DateTime     @default(now())
  enrollmentId String
  Enrollment   Enrollment   @relation(fields: [enrollmentId], references: [id], onDelete: Cascade)
}

model StudentBadge {
  id           String           @id @default(uuid())
  badgeType    StudentBadgeType
  earnedAt     DateTime         @default(now())
  metadata     Json?
  enrollmentId String
  Enrollment   Enrollment       @relation(fields: [enrollmentId], references: [id], onDelete: Cascade)

  @@unique([enrollmentId, badgeType])
}

model LoginSession {
  id           String     @id @default(uuid())
  device       String?
  browser      String?
  country      String?
  ipAddress    String?
  userAgent    String?
  loggedInAt   DateTime   @default(now())
  enrollmentId String
  Enrollment   Enrollment @relation(fields: [enrollmentId], references: [id], onDelete: Cascade)
}

model EarlyUnlock {
  id          String   @id @default(uuid())
  unlockedAt  DateTime @default(now())
  pointsSpent Int

  User      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  Chapter   Chapter? @relation(fields: [chapterId], references: [id], onDelete: Cascade)
  chapterId String?
  Lesson    Lesson?  @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  lessonId  String?

  @@unique([userId, chapterId, lessonId])
}

model LessonProgress {
  id        String   @id @default(uuid())
  completed Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    String
  lessonId  String
  Lesson    Lesson   @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  User      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, lessonId])
}

model Assignment {
  id          String                 @id @default(uuid())
  title       String
  description String?
  fileKey     String?
  points      Int?                   @default(100)
  dueDate     DateTime?
  createdAt   DateTime               @default(now())
  updatedAt   DateTime               @updatedAt
  lessonId    String                 @unique
  Lesson      Lesson                 @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  submissions AssignmentSubmission[]
}

model AssignmentSubmission {
  id              String                     @id @default(uuid())
  fileKey         String?
  status          AssignmentSubmissionStatus @default(Pending)
  grade           Int?
  feedback        String?
  submittedAt     DateTime                   @default(now())
  updatedAt       DateTime                   @updatedAt
  assignmentId    String
  userId          String
  description     String?
  link            String?
  submissionCount Int                        @default(1)
  Assignment      Assignment                 @relation(fields: [assignmentId], references: [id], onDelete: Cascade)
  User            User                       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, assignmentId])
}

model Quiz {
  id          String           @id @default(uuid())
  title       String?
  points      Int              @default(10)
  required    Boolean          @default(true)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  lessonId    String           @unique
  Lesson      Lesson           @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  questions   QuizQuestion[]
  submissions QuizSubmission[]
}

model QuizQuestion {
  id            String   @id @default(uuid())
  question      String
  options       String[] // Array of answer options
  correctAnswer Int // Index of correct answer (0-based)
  position      Int
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  quizId        String
  Quiz          Quiz     @relation(fields: [quizId], references: [id], onDelete: Cascade)

  @@unique([quizId, position])
}

model QuizSubmission {
  id             String   @id @default(uuid())
  score          Int // Percentage score
  totalQuestions Int
  correctAnswers Int
  pointsEarned   Int
  submittedAt    DateTime @default(now())
  updatedAt      DateTime @updatedAt
  quizId         String
  userId         String
  answers        Json // Store user's answers: { questionId: selectedOptionIndex }
  Quiz           Quiz     @relation(fields: [quizId], references: [id], onDelete: Cascade)
  User           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, quizId])
}

enum CourseLevel {
  Beginner
  Intermediate
  Advanced
}

enum CourseStatus {
  Draft
  Published
  Archived
}

enum BanType {
  Temporary
  Permanent
}

enum EnrollmentStatus {
  Pending
  Active
  Cancelled
}

enum StudentTag {
  TopPerformer
  NeedsHelp
  SlowLearner
  ActiveCommunicator
}

enum StudentBadgeType {
  FirstLessonCompleted
  SevenDayStreak
  HundredPercentProgress
  DiscussionContributor
  MonthlyTopPerformer
  WeeklyTopPerformer
}

enum ActivityType {
  LoggedIn
  CompletedLesson
  DownloadedFile
  MissedAssignment
  SubmittedAssignment
  ViewedLesson
  StartedCourse
}

enum AssignmentSubmissionStatus {
  Pending
  Graded
  Returned
}

enum LessonStatus {
  Draft
  Scheduled
  Published
}

enum ChapterStatus {
  Draft
  Scheduled
  Published
}

model SupportCall {
  id           String               @id @default(uuid())
  courseId     String
  createdBy    String // Admin user ID
  streamCallId String?              @unique // Stream.io call ID
  title        String?
  description  String?
  status       SupportCallStatus    @default(Active)
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt
  endedAt      DateTime?
  Course       Course               @relation(fields: [courseId], references: [id], onDelete: Cascade)
  Creator      User                 @relation("SupportCallCreator", fields: [createdBy], references: [id], onDelete: Cascade)
  requests     SupportCallRequest[]

  @@map("support_call")
}

model SupportCallRequest {
  id            String               @id @default(uuid())
  supportCallId String
  userId        String
  supportType   String // What type of support student needs
  status        SupportRequestStatus @default(Pending)
  position      Int // Queue position
  joinedAt      DateTime?
  createdAt     DateTime             @default(now())
  updatedAt     DateTime             @updatedAt
  SupportCall   SupportCall          @relation(fields: [supportCallId], references: [id], onDelete: Cascade)
  User          User                 @relation("SupportCallRequestUser", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([supportCallId, userId])
  @@map("support_call_request")
}

enum SupportCallStatus {
  Active
  Ended
  Cancelled
}

enum SupportRequestStatus {
  Pending
  Accepted
  Rejected
  Completed
}

// Blog System Models
model Blog {
  id              String         @id @default(uuid())
  title           String
  slug            String         @unique
  content         String         // Rich text content (HTML)
  excerpt         String?        // Short description for preview
  coverImageKey   String?        // S3 key for cover image
  seoTitle        String?
  seoDescription  String?
  readingTime     Int            @default(0) // in minutes
  status          BlogStatus     @default(Pending)
  isFeatured      Boolean        @default(false)
  isDraft         Boolean        @default(false)
  viewCount       Int            @default(0)
  likeCount       Int            @default(0)
  commentCount    Int            @default(0)
  pointsRequired  Int            @default(5) // Points needed to post
  pointsSpent     Int            @default(0) // Points deducted when posted
  pointsEarned    Int            @default(0) // Points earned from engagement
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  publishedAt     DateTime?
  rejectedAt      DateTime?
  rejectionReason String?
  authorId        String
  categoryId      String?
  courseId        String?        // Optional: link to course
  author          User           @relation(fields: [authorId], references: [id], onDelete: Cascade)
  category        BlogCategory?  @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  Course          Course?        @relation(fields: [courseId], references: [id], onDelete: SetNull)
  tags            BlogTag[]
  comments        BlogComment[]
  reactions       BlogReaction[]

  @@index([status])
  @@index([authorId])
  @@index([categoryId])
  @@index([isFeatured])
  @@index([createdAt])
  @@map("blog")
}

model BlogCategory {
  id          String   @id @default(uuid())
  name        String   @unique
  slug        String   @unique
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  blogs       Blog[]

  @@map("blog_category")
}

model BlogTag {
  id        String   @id @default(uuid())
  name      String
  slug      String
  blogId    String
  createdAt DateTime @default(now())
  blog      Blog     @relation(fields: [blogId], references: [id], onDelete: Cascade)

  @@unique([blogId, slug])
  @@index([slug])
  @@map("blog_tag")
}

model BlogComment {
  id        String         @id @default(uuid())
  content   String
  parentId  String?        // For threaded comments
  upvotes   Int            @default(0)
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  blogId    String
  authorId  String
  blog      Blog           @relation(fields: [blogId], references: [id], onDelete: Cascade)
  author    User           @relation(fields: [authorId], references: [id], onDelete: Cascade)
  parent    BlogComment?   @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies   BlogComment[]  @relation("CommentReplies")

  @@index([blogId])
  @@index([authorId])
  @@index([parentId])
  @@map("blog_comment")
}

model BlogReaction {
  id        String      @id @default(uuid())
  type      ReactionType
  createdAt DateTime    @default(now())
  blogId    String
  userId    String
  blog      Blog        @relation(fields: [blogId], references: [id], onDelete: Cascade)
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([blogId, userId])
  @@index([blogId])
  @@index([userId])
  @@map("blog_reaction")
}

model Notification {
  id        String           @id @default(uuid())
  type      NotificationType
  title     String
  message   String
  link      String?
  read      Boolean          @default(false)
  createdAt DateTime         @default(now())
  userId    String
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([read])
  @@map("notification")
}

enum BlogStatus {
  Pending
  Approved
  Rejected
  Published
}

enum ReactionType {
  Like
  Dislike
  Love
  Insightful
  Funny
}

enum NotificationType {
  BlogApproved
  BlogRejected
  CommentReceived
  ReactionReceived
  PointsEarned
  AdminReply
  SuperAdminInvitation
}

// Multi-tenant Workspace and Membership models
model Workspace {
  id          String       @id @default(uuid())
  name        String       @default("Default Workspace")
  slug        String       @unique @default("default")
  description String?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  memberships Membership[]
  invitations Invitation[]

  @@map("workspace")
}

model Membership {
  id          String    @id @default(uuid())
  userId      String
  workspaceId String
  role        WorkspaceRole @default(Member)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([userId, workspaceId])
  @@index([userId])
  @@index([workspaceId])
  @@map("membership")
}

model Invitation {
  id          String          @id @default(uuid())
  token       String          @unique
  email       String
  userId      String?         // Null if user doesn't exist yet
  workspaceId String
  role        WorkspaceRole
  status      InvitationStatus @default(Pending)
  invitedBy   String          // User ID who sent the invitation
  expiresAt   DateTime
  acceptedAt  DateTime?
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  user        User?           @relation("InvitedUser", fields: [userId], references: [id], onDelete: SetNull)
  workspace   Workspace       @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([email])
  @@index([userId])
  @@index([workspaceId])
  @@index([status])
  @@map("invitation")
}

enum WorkspaceRole {
  Member
  Admin
  SuperAdmin
}

enum InvitationStatus {
  Pending
  Accepted
  Expired
  Revoked
}

// Announcements System
model Announcement {
  id              String                    @id @default(uuid())
  title           String
  body            String                    // Rich text content (HTML)
  createdById     String
  targetRole      AnnouncementTargetRole
  targetCourseId  String?                   // Optional: specific course
  targetUserIds   String[]                  // Optional: specific user IDs (JSON array)
  scheduledAt     DateTime?                 // Optional: schedule for future
  publishedAt     DateTime?                 // When actually published
  status          AnnouncementStatus        @default(Draft)
  isUrgent        Boolean                   @default(false)
  attachmentKeys  String[]                  // S3 keys for attachments
  viewCount       Int                       @default(0)
  createdAt       DateTime                  @default(now())
  updatedAt       DateTime                  @updatedAt
  createdBy       User                      @relation("AnnouncementCreator", fields: [createdById], references: [id], onDelete: Cascade)
  targetCourse    Course?                   @relation(fields: [targetCourseId], references: [id], onDelete: SetNull)
  readStatuses    AnnouncementReadStatus[]

  @@index([createdById])
  @@index([targetCourseId])
  @@index([status])
  @@index([publishedAt])
  @@index([targetRole])
  @@map("announcement")
}

model AnnouncementReadStatus {
  id             String       @id @default(uuid())
  userId         String
  announcementId String
  readAt         DateTime     @default(now())
  user           User         @relation("AnnouncementReader", fields: [userId], references: [id], onDelete: Cascade)
  announcement   Announcement @relation(fields: [announcementId], references: [id], onDelete: Cascade)

  @@unique([userId, announcementId])
  @@index([userId])
  @@index([announcementId])
  @@map("announcement_read_status")
}

enum AnnouncementTargetRole {
  AllStudents
  AllTeachers
  AllUsers
  SpecificStudents
  SpecificTeachers
  CourseStudents
}

enum AnnouncementStatus {
  Draft
  Scheduled
  Published
  Expired
}

// Teacher Application & Verification System
model TeacherApplication {
  id              String                    @id @default(uuid())
  userId          String
  status          TeacherApplicationStatus  @default(Pending)
  applicationData Json                      // Store application form data
  rejectionReason String?
  reviewedBy      String?                   // Admin/Superadmin who reviewed
  reviewedAt      DateTime?
  createdAt       DateTime                  @default(now())
  updatedAt       DateTime                  @updatedAt
  user            User                      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId])
  @@index([status])
  @@index([createdAt])
  @@map("teacher_application")
}

enum TeacherApplicationStatus {
  Pending
  Approved
  Rejected
}

// Activity Logs for Teachers
model ActivityLog {
  id          String       @id @default(uuid())
  userId      String
  action      String       // e.g., "lesson_uploaded", "course_updated"
  entityType  String       // e.g., "course", "lesson", "chapter"
  entityId    String?
  metadata    Json?        // Additional context
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime     @default(now())
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@index([entityType, entityId])
  @@map("activity_log")
}

// Payment Transactions
model PaymentTransaction {
  id                String                    @id @default(uuid())
  enrollmentId      String
  amount            Int                       // Amount in cents
  currency          String                    @default("usd")
  stripePaymentId   String?                   @unique
  stripeSessionId   String?
  status            PaymentTransactionStatus  @default(Pending)
  paymentMethod     String?
  refunded          Boolean                   @default(false)
  refundAmount      Int?
  refundReason      String?
  refundedAt        DateTime?
  metadata          Json?
  createdAt         DateTime                  @default(now())
  updatedAt         DateTime                  @updatedAt
  enrollment        Enrollment                @relation(fields: [enrollmentId], references: [id], onDelete: Cascade)

  @@index([enrollmentId])
  @@index([status])
  @@index([createdAt])
  @@index([stripePaymentId])
  @@map("payment_transaction")
}

enum PaymentTransactionStatus {
  Pending
  Completed
  Failed
  Refunded
  Cancelled
}

// Course Ratings
model CourseRating {
  id          String                 @id @default(uuid())
  courseId    String
  userId      String
  rating      Int                    // 1-5
  comment     String?
  createdAt   DateTime               @default(now())
  updatedAt   DateTime               @updatedAt
  user        User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  course      Course                 @relation(fields: [courseId], references: [id], onDelete: Cascade)
  reactions   CourseRatingReaction[]

  @@unique([userId, courseId])
  @@index([courseId])
  @@index([rating])
  @@index([createdAt])
  @@map("course_rating")
}

model CourseRatingReaction {
  id          String       @id @default(uuid())
  ratingId    String
  userId      String
  reaction    ReactionType // Like or Dislike
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  rating      CourseRating @relation(fields: [ratingId], references: [id], onDelete: Cascade)
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([ratingId, userId])
  @@index([ratingId])
  @@index([userId])
  @@map("course_rating_reaction")
}

// Search Analytics
model SearchAnalytics {
  id            String   @id @default(uuid())
  userId        String?
  query         String
  resultsCount  Int      @default(0)
  clickedResult String?  // Course ID or lesson ID that was clicked
  ipAddress     String?
  userAgent     String?
  createdAt     DateTime @default(now())
  user          User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([query])
  @@index([createdAt])
  @@index([resultsCount])
  @@map("search_analytics")
}

// Login History & Security
model LoginHistory {
  id            String          @id @default(uuid())
  userId        String
  ipAddress     String?
  userAgent     String?
  country       String?
  city          String?
  success       Boolean         @default(true)
  failureReason String?
  deviceInfo    Json?
  createdAt     DateTime        @default(now())
  user          User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([success])
  @@index([createdAt])
  @@index([ipAddress])
  @@map("login_history")
}

// Error Logs
model ErrorLog {
  id          String   @id @default(uuid())
  userId      String?
  errorType   String   // e.g., "API_ERROR", "VALIDATION_ERROR", "DATABASE_ERROR"
  statusCode  Int?
  message     String
  stack       String?
  endpoint    String?
  method      String?
  metadata    Json?
  createdAt   DateTime @default(now())
  user        User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([errorType])
  @@index([statusCode])
  @@index([createdAt])
  @@map("error_log")
}

// System Configuration
model SystemConfig {
  id          String   @id @default(uuid())
  key         String   @unique
  value       Json
  description String?
  updatedBy   String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([key])
  @@map("system_config")
}

// Lesson Watch Analytics
model LessonWatchAnalytics {
  id              String   @id @default(uuid())
  lessonId        String
  userId          String
  watchDuration   Int      // seconds watched
  totalDuration   Int      // total lesson duration in seconds
  completionRate  Float    // percentage completed
  lastWatchedAt   DateTime @default(now())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  lesson          Lesson   @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, lessonId])
  @@index([lessonId])
  @@index([userId])
  @@index([completionRate])
  @@map("lesson_watch_analytics")
}

// Online User Sessions
model OnlineSession {
  id          String   @id @default(uuid())
  userId      String
  sessionId   String   @unique
  ipAddress   String?
  userAgent   String?
  lastActivityAt DateTime @default(now())
  createdAt   DateTime @default(now())
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([lastActivityAt])
  @@map("online_session")
}

// Help Requests
model HelpRequest {
  id          String              @id @default(uuid())
  userId      String
  subject     String
  message     String
  userType    HelpRequestUserType
  status      HelpRequestStatus   @default(Pending)
  response    String?
  respondedAt DateTime?
  userReply   String?
  userRepliedAt DateTime?
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  user        User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@index([userType])
  @@map("help_request")
}

enum HelpRequestStatus {
  Pending
  InProgress
  Resolved
  Closed
}

enum HelpRequestUserType {
  Teacher
  Student
  Admin
}

// Wishlist Model
model Wishlist {
  id        String   @id @default(uuid())
  userId    String
  courseId  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  course    Course   @relation(fields: [courseId], references: [id], onDelete: Cascade)

  @@unique([userId, courseId])
  @@index([userId])
  @@index([courseId])
  @@map("wishlist")
}
